# 4_内核队列kfifo



## 相关链接







## 队列基础知识

我们知道 队列 也是一种 <font color=red>生产者消费者模型</font>，具有<font color=red>先进先出</font>的特点。

![image-20210410143637433](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210410143637433.png)

队列需要提供以下基本操作功能

- 队列的分配
- 队列的初始化
- 队列的释放
- 队列的数据入列
- 队列的数据出列
- 队列判满
- 队列判空





## 内核队列的实现

Linux内核链表位于 *include/linux/kfifo.h*  和 *lib/kfifo.c* 代码中 ，使用了一个<font color=red>环形缓冲区, 配合两个位置参数 in/out ，它们的差值来指定当前的 fifo 的状态.</font>



<font color=red>内核队列的设计精妙之处在于:</font>

- 保证缓冲区大小为2的次幂，不是的 <font color=red>向上取整</font>为2的次幂。
- 使用无符号整数保存输入(in)和输出(out)的位置，在输入输出时不对in和out的值进行模运算，而让其自然溢出，并能够保证in-out的结果为缓冲区中已存放的数据长度.
- 将需要取模的运算用 & 操作代替（ a % size = (a & (size − 1)) ), 这需要size保证为2的次幂。
- 使用内存屏障(Memory Barrier)技术，实现单消费者和单生产者对kfifo的无锁并发访问，多个消费者、生产者的并发访问还是需要加锁的（本文不涉及）
  



这里只简单整理下常用API和 一些特殊点

注：可参考<font color=green>《Linux内核设计与实现 第三版》 6.2章节</font>，也可参考 [内核数据结构 —— 内核队列](https://blog.csdn.net/zhoutaopower/article/details/86491852)。



### 队列的数据结构

```
struct __kfifo {
	unsigned int	in;      // 入列的时候增加的位置
	unsigned int	out;     // 出列的时候增加的位置
	unsigned int	mask;    // 巧妙的 mask 设计，同时包含了数据的个数信息
	unsigned int	esize;   // 元素的大小
	void            *data;   // 数据
};
```



### 队列的申请和释放

#### 动态申请

```
/**
 * kfifo_alloc - dynamically allocates a new fifo buffer
 * @fifo: pointer to the fifo
 * @size: the number of elements in the fifo, this must be a power of 2
 * @gfp_mask: get_free_pages mask, passed to kmalloc()
 */

#define kfifo_alloc(fifo, size, gfp_mask) .....

int __kfifo_alloc(struct __kfifo *fifo, unsigned int size,
		size_t esize, gfp_t gfp_mask)  // ??? esize
{
	size = roundup_pow_of_two(size);  // 如果传入参数不是2^n，那么向下

	fifo->in = 0;
	fifo->out = 0;
	fifo->esize = esize;	// esize为每个元素的大小，也就是数据结构的大小

	fifo->data = kmalloc(size * esize, gfp_mask);	// 申请内存

	fifo->mask = size - 1;			// 我们知道 2^n掩码是 2^n-1（低bit全部为1）

	return 0;
}

```

esize 赋值给 fifo->esize 这个是代表了队列中数据的类型的 size，比如队列数据类型如果为 int，则 esize 等于 4.

![image-20210410151007918](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210410151007918.png)



#### 释放

动态申请的kfifo一定要释放

```
/**
 * kfifo_free - frees the fifo
 * @fifo: the fifo to be freed
 */
#define kfifo_free(fifo) ......
```



#### 静态申请 （了解）

DECLARE_KFIFO + INIT_KFIFO = DEFINE_KFIFO  定义并初始化KFIFO

```
/**
 * macro to declare a fifo object  // 静态申请kfifo结构
 * @fifo: name of the declared fifo  // kfifo变量名
 * @type: type of the fifo elements  // kfifo数据结构
 * @size: the number of elements in the fifo, this must be a power of 2 // kfifo大小，必须是2的指数
 */

// 定义+初始化
#define DECLARE_KFIFO(fifo, type, size)	STRUCT_KFIFO(type, size) fifo 
#define INIT_KFIFO(fifo)  ......

// 定义 同时初始化
#define DEFINE_KFIFO(fifo, type, size)  .....
```





### 队列的入队和出队

#### 队列的入队

```
#define	kfifo_put(fifo, val)
```





#### 队列的出队





### 队列的判空判满







### 内核kfifo demo









## 内核队列的使用





## 用户态队列的移植

