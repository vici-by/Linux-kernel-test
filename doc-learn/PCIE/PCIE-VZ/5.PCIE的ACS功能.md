# PCIE的ATS功能



## 相关参考和目标

### 参考资料

* <font color=#008000>《PCI+EXPRESS体系结构导读.pdf》13.2节</font>
* <font color=#008000>《PCI Express Base_r5_1.pdf》第10章</font>

### 目标

* 了解ATS的作用
* 学习ATS在协议中的描述
* 学习ATS在Linux代码中的实现部分





## 协议总览

### ATS Architectural Overview

#### 总线地址和存储域地址

在PCIE基础知识中，我们都知道：<font color=Blue>BAR空间的地址 为总线地址， 在使用时（Intel机器）会在MMIO存储域分配一块地址，来将PCIE 总线域的地址映射到存储域</font>。

在DMA基础时，我们都说过：<font Color=blue>DMA设备填充的是总线地址，而不是存储域地址</font>



<font color=red>什么是存储域地址，什么是总线域地址?</font>

* <font color=red>物理地址是指站在CPU角度，CPU经过MMU（+EPT）之后发出的地址，可以落实到真实的物理MMIO空间，用来访问内存或者设备</font>

* <font color=red>总线地址是指从从设备角度来看整个CPU端的地址，会将CPU端MMIO空间全部映射在设备端（一般是设备端提供一个基地址，访问 基地址+offset 即可访问到CPU端的地址， 这个基地址+偏移， 就是外设使用的总线地址</font>
* 使用一致性dma或者流式dma接口时，会 根据设备来将 CPU地址转换为总线地址返回。



```
               CPU                  CPU                  Bus
             Virtual              Physical             Address
             Address              Address               Space
              Space                Space

            +-------+             +------+             +------+
            |       |             |MMIO  |   Offset    |      |
            |       |  Virtual    |Space |   applied   |      |
          C +-------+ --------> B +------+ ----------> +------+ A
            |       |  mapping    |      |   by host   |      |
  +-----+   |       |             |      |   bridge    |      |   +--------+
  |     |   |       |             +------+             |      |   |        |
  | CPU |   |       |             | RAM  |             |      |   | Device |
  |     |   |       |             |      |             |      |   |        |
  +-----+   +-------+             +------+             +------+   +--------+
            |       |  Virtual    |Buffer|   Mapping   |      |
          X +-------+ --------> Y +------+ <---------- +------+ Z
            |       |  mapping    | RAM  |   by IOMMU
            |       |             |      |
            |       |             |      |
            +-------+             +------+
```



大多数现代系统体系结构都提供了从 DMA I/O 地址转换功能-IOMMU/VT-D/SMMU（后边统一说IOMMU）.

IOMMU在RC端集成，外设通过DMA访问CPU存储域空间时，由IOMMU进行地址转换和保护。

![image-20210409165857492](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409165857492.png)

![image-20210409173421718](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409173421718.png)



IOMMU的功能包括：

* 限制“中断”或未正确编程的DMA I/O功能的破坏性
* 提供分散/聚集
* 能够将消息信号中断（例如MSI或MSI-X）重定向到不同的Domain。
* 地址空间转换（将32位I/O功能转换为更大的系统地址空间）
* 虚拟化Virtualization支持



IOMMU引发的问题：

不管是为了什么功能，主机系统中DMA地址转换的存在对DMA访问<font color=red>有一定的性能影响（ 由于解析实际物理地址所需的时间，DMA访问时间显著延长）</font>。

如果实现机制是  需要访问驻留在主存储器中的页表，则访问时间可能比未翻译的访问时间长得多。 另外，如果每个事务需要多个内存访问（例如，对于表遍历），那么与DMA相关联的内存事务速率（即开销）可以很高。











#### ATS的作用

前边说过，IOMMU对于每个TLP包发来的地址，都会从TA将总线地址转为对应的物理地址（HPA），造成了很大的性能影响。

为了减轻这个查找页表造成的性能影响，<font color=red>引入了ACS（类似于CPU的TLB），这里叫做Address Translation cache 或者ATC</font>。

> TLB是MMU的一个缓存表，CPU发出VA时需要通过MMU转换为PA， 这时需要查询页表。为了提高性能，MMU内部集成了一个Cache，可以按页缓存页表项， CPU发的的VA在命中TLB时，可以快速定位到真实的物理地址。
>
> ![image-20210409172428323](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409172428323.png)



<font color=red>举例说明TLB和TA的作用</font>：

TLB和ACS就像微信聊天的 “主页”，其实就是最近联系人界面， 这个相当于快速通道。    能在最近联系人界面找到需要聊天的人，这就是Cache命中。

如果与某个人没聊过天，则需要从联系人列表去找，这就是TTW和TA， 比较麻烦。  这就是Cache未命中。

从联系人找到后，聊了一句话之后，就可以在最近联系人界面找到了，下次在聊就可以直接走“快速通道”。 这个过程，叫做刷新Cache。













PCIE设备集成ATC的优点：

* 通过分配地址转换缓存职责来减轻TA资源压力的能力（减少TA内“抖动”的可能性）

* 使ATC设备对系统 ATC size 的性能依赖性更小

* 通过向 central complex 发送预翻译请求，确保最佳访问延迟的可能性

> Spec 提供 允许PCIe设备与TA一起使用的互操作性，但TA及其 Address Translation and Protection T able (ATPT)被视为特定于实现的，不在Spec的范围内。



![](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409173754734.png)





#### Address Translation Services (ATS) Overview

ATS提供了一组TLP报文。 ATS使用 EP和RC request-completion protocol   来提供 translation  服务。另外，<font color=red>在内存读写 TLP中定义了一个新的AT字段。新的 AT字段使RC能够确定给定的请求是否已经通过ATS协议被翻译</font>



![image-20210409174526890](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409174526890.png)



在该示例中，single-Function PCIe Device   接收特定于功能的工作请求。

函数决定
通过一种特定于实现的方法，将翻译缓存在TC中将是有益的。有一个
一个功能或软件在作出这样的决定时可以考虑的因素的数目；例如：
•在较长时间内频繁访问的内存地址范围或其相关的缓冲区内容的更新率很高
•内存地址范围，如工作和完成队列结构，用于低延迟的数据缓冲区通信、图形帧缓冲区、用于缓存函数特定内容的主机内存等

向前地
考虑到设计和访问模式的可变性，没有单一的标准可以应用。
该函数生成TS转换请求，该请求通过PCIe层次结构向上游发送到RC，RC
然后转发给助教。ATS转换请求使用与本节中定义的相同的路由和排序规则
规范。此外，多个TS翻译请求在任何给定时间都可以是未完成的；即，一个可能是未完成的
一个或多个TC上的多个请求。每个TC代表一个唯一的排序域，并定义必须
由关联的翻译完成程序使用







收到一个 ATS Translation Request 请求后，TA执行下列操作

* 验证功能 是否已配置为发出ATS翻译请求。
* 确定 该Function设备  是否可以访问由 ATS翻译 请求指示的内存并具有相关的 访问权限。
* 确定是否可以向函数提供translation。如果是的话，TA会对函数进行翻译
* 。。。。。





![image-20210409182056016](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409182056016.png)



#### Page Request Interface Extension

ATS改进了基于DMA的数据拷贝行为。  关联的Page Request Interface （PRI <font color=red>注：这里不是优先级</font>）  通过   允许DMA操作被启动而不需要将要移入或移出系统内存的所有数据固定，从而 提供额外的优势。











#### Process Address Space ID (PASID)

某些<font color=blue> TLP 可以选择与进程地址空间ID（PASID）相关联。该值使用PASID TLP前缀传递</font>。PASID TLP前缀在第6.20节中定义。

每个Function 都有一组独立的PASID值。PASID字段宽度为20位*(但有效宽度为 受 Root Complex (TA)   支持的宽度和 ATC   支持的宽度中较小者的约束。*

*PASID值的未使用高位必须为0b)*。

> 我们知道，IOMMU可以开启2级地址翻译，将DMA映射到用户进程空间， 其中PASID就是用来管理进程ID和进程对应的虚拟页表的。



PASID TLP前缀允许在：

* 具有未转换地址的内存请求（包括Untranslated AtomicOp Requests）

* Address Translation Requests

* Page Request Messages

* ATS Invalidation Requests

* PRG Response Messages



具有  PASID的地址通常用于表示（GVA）与PASID关联的地址表示来宾物理地址（GPA）。

EPT执行GPA->HPA，而各个Guest OS管理用于执行从GVA到GPA的转换的表

当用相关联的PASID翻译地址时，TA执行两种翻译并返回翻译后的地址（即GVA到GPA，然后GPA到HPA）。中间GPA值对ATC不可见



问题： <font color=red>这里ATC到底起了什么作用？？？？</font>



















### ATS Translation Services

#### Memory Requests with Address Type

前边说过，支持ATS功能的设备，<font color=red>在内存读写 TLP中定义了一个新的AT字段。新的 AT字段使RC能够确定给定的请求是否已经通过ATS协议被翻译</font>

![image-20210409182229515](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409182229515.png)

![image-20210409182238154](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409182238154.png)

![image-20210409182402435](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409182402435.png)







#### Translation Requests





#### Translation Completion





### ATS Invalidation





### Page Request Services



### ATS Configuration

#### ATS Extended Capability

ATS配置空间位于PCIE Extended配置空间

![image-20210409183117148](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183117148.png)

##### Capability Header

![image-20210409183556872](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183556872.png)

##### ATS Cap Register

![image-20210409183313226](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183313226.png)

##### ATS Control Register (Offset 06h)

![image-20210409183345537](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183345537.png)

![image-20210409183337716](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183337716.png)



#### Page Request Extended Capability Structure

![image-20210409183631673](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183631673.png)

##### Page Request Extended Capability Header (Offset 00h)

![image-20210409183649492](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183649492.png)



##### Page Request Control Register (Offset 04h)

![image-20210409183712749](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183712749.png)

![image-20210409183719248](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183719248.png)















## ATS的软件操作

### ATS初始化

代码中只保存了ATS CAP的位置

```
linux-4.14.89\drivers\pci\ats.c

pci_init_capabilities
	pci_ats_init(dev);
		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ATS);
		struct pci_dev *ats_cap = pos; 
```



### 支持接口

#### enable 和 disable

```
pci_enable_ats
	ctrl = PCI_ATS_CTRL_ENABLE;
	dev->ats_stu = ps;	// ps为页大小 #define VTD_PAGE_SHIFT		(12)
	ctrl |= PCI_ATS_CTRL_STU(dev->ats_stu - PCI_ATS_MIN_STU);  // 计算STU
	pci_write_config_word(dev, dev->ats_cap + PCI_ATS_CTRL, ctrl);
	

pci_disable_ats
	ctrl &= ~PCI_ATS_CTRL_ENABLE;
	pci_write_config_word(dev, dev->ats_cap + PCI_ATS_CTRL, ctrl);
```



#### pri配置





#### pasid配置

