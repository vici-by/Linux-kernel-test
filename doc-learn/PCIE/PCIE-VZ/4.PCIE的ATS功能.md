# PCIE的ATS功能



## 相关参考和目标

### 参考资料

* <font color=#008000>《PCI+EXPRESS体系结构导读.pdf》13.2节</font>
* <font color=#008000>《PCI Express Base_r5_1.pdf》第10章</font>
* [《PCIe_IOV_WP_CHS》](https://www.docin.com/p-134308563.html)

### 目标

* 了解ATS的作用
* 学习ATS在协议中的描述
* 学习ATS在Linux代码中的实现部分





## 协议总览

### ATS Architectural Overview

#### 总线地址和存储域地址

在PCIE基础知识中，我们都知道：<font color=Blue>BAR空间的地址 为总线地址， 在使用时（Intel机器）会在MMIO存储域分配一块地址，来将PCIE 总线域的地址映射到存储域</font>。

在DMA基础时，我们都说过：<font Color=blue>DMA设备填充的是总线地址，而不是存储域地址</font>



<font color=red>什么是存储域地址，什么是总线域地址?</font>

* <font color=red>物理地址是指站在CPU角度，CPU经过MMU（+EPT）之后发出的地址，可以落实到真实的物理MMIO空间，用来访问内存或者设备</font>

* <font color=red>总线地址是指从从设备角度来看整个CPU端的地址，会将CPU端MMIO空间全部映射在设备端（一般是设备端提供一个基地址，访问 基地址+offset 即可访问到CPU端的地址， 这个基地址+偏移， 就是外设使用的总线地址</font>
* 使用一致性dma或者流式dma接口时，会 根据设备来将 CPU地址转换为总线地址返回。



```
               CPU                  CPU                  Bus
             Virtual              Physical             Address
             Address              Address               Space
              Space                Space

            +-------+             +------+             +------+
            |       |             |MMIO  |   Offset    |      |
            |       |  Virtual    |Space |   applied   |      |
          C +-------+ --------> B +------+ ----------> +------+ A
            |       |  mapping    |      |   by host   |      |
  +-----+   |       |             |      |   bridge    |      |   +--------+
  |     |   |       |             +------+             |      |   |        |
  | CPU |   |       |             | RAM  |             |      |   | Device |
  |     |   |       |             |      |             |      |   |        |
  +-----+   +-------+             +------+             +------+   +--------+
            |       |  Virtual    |Buffer|   Mapping   |      |
          X +-------+ --------> Y +------+ <---------- +------+ Z
            |       |  mapping    | RAM  |   by IOMMU
            |       |             |      |
            |       |             |      |
            +-------+             +------+
```



#### IOMMU带来的好处和缺陷

##### IOMMU的功能

大多数现代系统体系结构都提供了从 DMA I/O 地址转换功能-IOMMU/VT-D/SMMU（后边统一说IOMMU）.

IOMMU在RC端集成，外设通过DMA访问CPU存储域空间时，由IOMMU进行地址转换和保护。

![image-20210409165857492](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409165857492.png)





##### IOMMU的转换原理

设备发来的总线地址，经过RC以后转换为GPA，但要访问实际物理内存，需要用HPA。

![image-20210410103820465](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210410103820465.png)

在学习IOMMU的原理时，知道IOMMU是根据BDF定位到设备所属的domain所在的iommu group中，则直接绑定到对应的EPT页表中。

![image-20210410103719979](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210410103719979.png)

（Second-level Page Table Structures 根据BDF为列表索引定位到对应的EPT硬件页表上去）。



其实，IOMMU里边包含了TA（Translation Agent-地址转换部件）和ATPT（Address Translation and Protection Table-地址转换和保护表），

TLP包在经过RC后将总线地址转为了GPA，先到了TA，根据ATPT来索引EPT页表将GPA转为了HPA。

![image-20210410105934148](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210410105934148.png)



##### IOMMU的好处

* 限制“中断”或未正确编程的DMA I/O功能的破坏性- DMA传输越界到不同的domain上去（比如通过DMA直接给MSI Vector地址写数据是不行的）。
* 提供DMA的分散/聚集传输（页表的存在，使得DMA支持不连续的物理内存传输）。
* 能够将MSI/MSI-X中断重定向到不同的Domain。
* 地址空间转换（将32位I/O功能转换为更大的系统地址空间）。
* 虚拟化Virtualization支持。







##### IOMMU引发的问题

不管是为了什么功能，主机系统中DMA地址转换的存在对DMA访问<font color=red>有一定的性能影响（ 由于解析实际物理地址所需的时间，DMA访问时间显著延长）</font>。

如果实现机制是  需要访问驻留在主存储器中的页表，则访问时间可能比未翻译的访问时间长得多。 另外，如果每个事务需要多个内存访问（例如，对于表遍历），那么与DMA相关联的内存事务速率（即开销）可以很高。







#### ATC的作用

前边说过，<font color=red>IOMMU</font>对于每个TLP包发来的地址，都会从TA将总线地址转为对应的物理地址（HPA），<font color=red>造成了很大的性能影响</font>。

为了<font color=red>减轻IOMMU这个查找页表造成的性能影响，引入了ACS（类似于CPU的TLB），这里叫做Address Translation cache 或者ATC</font>。

> TLB是MMU的一个缓存表，CPU发出VA时需要通过MMU转换为PA， 这时需要查询页表。为了提高性能，MMU内部集成了一个Cache，可以按页缓存页表项， CPU发的的VA在命中TLB时，可以快速定位到真实的物理地址。
>
> ![image-20210409172428323](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409172428323.png)



<font color=red>举例说明TLB和TA的作用</font>：

TLB和ATC就像微信聊天的 “主页”-最近联系人界面， 这个相当于快速通道。    能在最近联系人界面找到需要聊天的人，这就是Cache命中。

如果与某个人没聊过天，则需要从联系人列表去找，这就是TTW和TA， 比较麻烦。  这就是Cache未命中。

从联系人找到后，聊了一句话之后，就可以在最近联系人界面找到了，下次在聊就可以直接走“快速通道”。 这个过程，叫做刷新Cache。









<font color=red>PCIE设备集成ATC的优点</font>

* 通过ATC来减轻ATPT的压力（减少TA内“抖动（刷Cache）”的次数）
* 使ATC设备对  “System ATC size” 的性能依赖性更小。 
* 设备能够根据功能类型优化ATC性能
* 通过向 central complex 发送预翻译请求，确保最佳访问延迟的可能性

> Spec 提供 允许PCIe设备与TA一起使用的互操作性，但TA及其 Address Translation and Protection T able (ATPT)被视为特定于实现的，不在Spec的范围内。



基于ATC的框架图如下：

![](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409173754734.png)





#### ATS Overview

前边一直说ATC，但本文内容是ATS，那么什么是ATS？ 



##### ATS的作用

ATS（Address Translation Services）定义了一组新的TLP， 使用 EP和RC request-completion protocol   来提供 address translation  Services。

另外，<font color=red>在MemRd和MemWr报文中 TLP中定义了一个新的AT字段。新的 AT字段使RC能够确定当前的TLP请示 是否已经通过ATS协议被翻译</font>（参考后边：Memory Requests with Address Type）



##### Single-function PCIE设备

图示说明：ATS转换请求操作的基本流程

![image-20210409174526890](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409174526890.png)



在此示例中， single-Function PCIe Device 发送和接收 ATS Request 和 ATS Completion请求。 

该 功能通过特定于实现的方法确定在其 ATC中进行地址转换可以带来性能上提升而还是下降

* 在较长时间内频繁访问内存地址范围， 或相关缓冲区的更新率很高。
* 内存地址范围，如工作和完成队列结构，用于低延迟的数据缓冲区通信、图形帧缓冲区、用于缓存函数特定内容的主机内存等

总结：其实就是Cache命中率高不高的问题，在Cache命中率很高的情况下会带来性能显著提升。 在Cache命中率不高的情况下，会频繁刷新Cache，造成Cache抖动很大，那么反而影响了性能。





PCI设备生成一个ATS转换请求，该请求通过PCIe层次结构上游发送给RC，然后由RC转发给TA。

ATS转换请求使用与Spec中定义的相同的路由和排序规则。 此外，在任何给定时间都可能有多个ATS转换请求未完成； 也就是说，ATS请求可能在一个或多个TC上流水线处理多个请求。 每个TC代表一个唯一的排序域，并定义关联的ATS转换完成必须使用的域。





TA收到ATS Request的操作（TBD）

收到一个 ATS Translation Request 请求后，TA执行下列操作

* 验证 该 Function    是否已配置为发出ATS转换请求。
* 确定 该Function设备 是否可以访问 ATS转换请求指示的内存并具有关联的访问权限。
* 确定是否可以向Function能提供translation。 如果可以，则TA向Function发布translation。
* 



ATC收到ATS Translation Completion 的操作（TBD）







#### mult-function 设备

前边描述的是single-Function PCIe Device，那么multi-Function PCIE Device内部是什么样子？



Multi-Function PCIE Device 的特点：

* 每个ATC与一个Function关联。  每个支持ATS-CAP 必须能够发出和接收每种 ATS   Translation Request  或 Translation Completion  类型中的至少一种。。
* 每个ATC在每个 Function的基础上进行配置和访问。 Multi-Function PCIE Device 不需要在每个Function 上实现ATS。
* 如果ATC实施在一组 Function 之间共享资源，则要求逻辑行为与完全独立的ATC实施一致



![image-20210409182056016](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409182056016.png)





![image-20210410140456671](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210410140456671.png)







![image-20210410140505283](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210410140505283.png)







#### Page Request Interface Extension

ATS改进了基于DMA的数据拷贝行为。  关联的Page Request Interface （PRI <font color=red>注：这里不是优先级</font>）  通过   允许DMA操作被启动而不需要将要移入或移出系统内存的所有数据固定，从而 提供额外的优势。











#### Process Address Space ID (PASID)

某些<font color=blue> TLP 可以选择与进程地址空间ID（PASID）相关联。该值使用PASID TLP前缀传递</font>。PASID TLP前缀在第6.20节中定义。

每个Function 都有一组独立的PASID值。PASID字段宽度为20位*(但有效宽度为 受 Root Complex (TA)   支持的宽度和 ATC   支持的宽度中较小者的约束。*

*PASID值的未使用高位必须为0b)*。

> 我们知道，IOMMU可以开启2级地址翻译，将DMA映射到用户进程空间， 其中PASID就是用来管理进程ID和进程对应的虚拟页表的。



PASID TLP前缀允许在：

* 具有未转换地址的内存请求（包括Untranslated AtomicOp Requests）

* Address Translation Requests

* Page Request Messages

* ATS Invalidation Requests

* PRG Response Messages



具有  PASID的地址通常用于表示（GVA）与PASID关联的地址表示来宾物理地址（GPA）。

EPT执行GPA->HPA，而各个Guest OS管理用于执行从GVA到GPA的转换的表

当用相关联的PASID翻译地址时，TA执行两种翻译并返回翻译后的地址（即GVA到GPA，然后GPA到HPA）。中间GPA值对ATC不可见



问题： <font color=red>这里ATC到底起了什么作用？？？？</font>



















### ATS Translation Services

#### Memory Requests with Address Type

前边说过，支持ATS功能的设备，<font color=red>在内存读写 TLP中定义了一个新的AT字段。新的 AT字段使RC能够确定给定的请求是否已经通过ATS协议被翻译</font>

![image-20210409182229515](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409182229515.png)

![image-20210409182238154](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409182238154.png)

![image-20210409182402435](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409182402435.png)







#### Translation Requests





#### Translation Completion





### ATS Invalidation





### Page Request Services



### ATS Configuration

#### ATS Extended Capability

ATS配置空间位于PCIE Extended配置空间

![image-20210409183117148](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183117148.png)

##### Capability Header

![image-20210409183556872](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183556872.png)

##### ATS Cap Register

![image-20210409183313226](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183313226.png)

##### ATS Control Register (Offset 06h)

![image-20210409183345537](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183345537.png)

![image-20210409183337716](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183337716.png)



#### Page Request Extended Capability Structure

![image-20210409183631673](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183631673.png)

##### Page Request Extended Capability Header (Offset 00h)

![image-20210409183649492](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183649492.png)



##### Page Request Control Register (Offset 04h)

![image-20210409183712749](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183712749.png)

![image-20210409183719248](C:\Users\baiy\AppData\Roaming\Typora\typora-user-images\image-20210409183719248.png)















## ATS的软件操作

### ATS初始化

代码中只保存了ATS CAP的位置

```
linux-4.14.89\drivers\pci\ats.c

pci_init_capabilities
	pci_ats_init(dev);
		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ATS);
		struct pci_dev *ats_cap = pos; 
```



### 支持接口

#### enable 和 disable

```
pci_enable_ats
	ctrl = PCI_ATS_CTRL_ENABLE;
	dev->ats_stu = ps;	// ps为页大小 #define VTD_PAGE_SHIFT		(12)
	ctrl |= PCI_ATS_CTRL_STU(dev->ats_stu - PCI_ATS_MIN_STU);  // 计算STU
	pci_write_config_word(dev, dev->ats_cap + PCI_ATS_CTRL, ctrl);
	

pci_disable_ats
	ctrl &= ~PCI_ATS_CTRL_ENABLE;
	pci_write_config_word(dev, dev->ats_cap + PCI_ATS_CTRL, ctrl);
```



#### pri配置





#### pasid配置

